<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Avalanche C-Chain Testnet Transactions</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap");

      :root {
        --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        --danger-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        --dark-bg: #0f0f23;
        --card-bg: rgba(255, 255, 255, 0.1);
        --glass-bg: rgba(255, 255, 255, 0.08);
        --text-primary: #ffffff;
        --text-secondary: rgba(255, 255, 255, 0.7);
        --border-color: rgba(255, 255, 255, 0.1);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: linear-gradient(
          135deg,
          #0c0c1d 0%,
          #1a1a3a 50%,
          #2d1b69 100%
        );
        min-height: 100vh;
        color: var(--text-primary);
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 25% 25%,
            rgba(120, 119, 198, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 75% 75%,
            rgba(255, 118, 117, 0.3) 0%,
            transparent 50%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        position: relative;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
        padding: 60px 0;
      }

      .header h1 {
        font-size: 4rem;
        font-weight: 800;
        background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
        background-size: 200% 200%;
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: gradientShift 3s ease-in-out infinite;
        margin-bottom: 20px;
      }

      .header p {
        font-size: 1.2rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      @keyframes gradientShift {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
      }

      .card {
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        border: 1px solid var(--border-color);
        border-radius: 20px;
        padding: 30px;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 2px;
        background: var(--primary-gradient);
        transform: scaleX(0);
        transition: transform 0.3s ease;
      }

      .card:hover {
        transform: translateY(-5px);
        border-color: rgba(255, 255, 255, 0.2);
      }

      .card:hover::before {
        transform: scaleX(1);
      }

      .card-title {
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .card-icon {
        font-size: 1.8rem;
      }

      .full-width {
        grid-column: 1 / -1;
      }

      .btn {
        background: var(--primary-gradient);
        border: none;
        border-radius: 12px;
        padding: 14px 28px;
        font-size: 1rem;
        font-weight: 600;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        margin: 8px 8px 8px 0;
        text-decoration: none;
        position: relative;
        overflow: hidden;
      }

      .btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .btn:hover::before {
        left: 100%;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background: linear-gradient(135deg, #434343 0%, #000000 100%);
      }

      .btn-secondary:hover {
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }

      .btn-success {
        background: var(--success-gradient);
      }

      .btn-success:hover {
        box-shadow: 0 10px 25px rgba(79, 172, 254, 0.4);
      }

      .btn-danger {
        background: var(--danger-gradient);
      }

      .btn-danger:hover {
        box-shadow: 0 10px 25px rgba(250, 112, 154, 0.4);
      }

      .input-group {
        margin-bottom: 20px;
      }

      .input-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        color: var(--text-primary);
      }

      .input {
        width: 100%;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 16px 20px;
        font-size: 1rem;
        color: var(--text-primary);
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .input::placeholder {
        color: var(--text-secondary);
      }

      .input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        background: rgba(255, 255, 255, 0.08);
      }

      .status {
        padding: 16px 20px;
        border-radius: 12px;
        margin: 16px 0;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 10px;
        backdrop-filter: blur(10px);
      }

      .status.success {
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.2),
          rgba(56, 142, 60, 0.2)
        );
        border: 1px solid rgba(76, 175, 80, 0.3);
        color: #81c784;
      }

      .status.error {
        background: linear-gradient(
          135deg,
          rgba(244, 67, 54, 0.2),
          rgba(211, 47, 47, 0.2)
        );
        border: 1px solid rgba(244, 67, 54, 0.3);
        color: #e57373;
      }

      .status.warning {
        background: linear-gradient(
          135deg,
          rgba(255, 152, 0, 0.2),
          rgba(245, 124, 0, 0.2)
        );
        border: 1px solid rgba(255, 152, 0, 0.3);
        color: #ffb74d;
      }

      .wallet-info {
        background: rgba(255, 255, 255, 0.03);
        border-radius: 12px;
        padding: 20px;
        margin: 16px 0;
      }

      .wallet-info h4 {
        color: var(--text-primary);
        margin-bottom: 8px;
        font-weight: 500;
      }

      .wallet-info p {
        color: var(--text-secondary);
        word-break: break-all;
        font-family: "Courier New", monospace;
        background: rgba(255, 255, 255, 0.05);
        padding: 8px 12px;
        border-radius: 8px;
        margin: 8px 0;
      }

      .network-badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: var(--success-gradient);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 600;
        margin-bottom: 20px;
      }

      .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 0.8s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .transaction-result {
        background: rgba(76, 175, 80, 0.1);
        border: 1px solid rgba(76, 175, 80, 0.2);
        border-radius: 12px;
        padding: 20px;
        margin-top: 20px;
      }

      .explorer-link {
        color: #667eea;
        text-decoration: none;
        font-weight: 600;
      }

      .explorer-link:hover {
        text-decoration: underline;
      }

      @media (max-width: 768px) {
        .grid {
          grid-template-columns: 1fr;
          gap: 20px;
        }

        .header h1 {
          font-size: 2.5rem;
        }

        .card {
          padding: 20px;
        }

        .container {
          padding: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üèîÔ∏è Avalanche DApp</h1>
        <p>Seamless transactions on Fuji Testnet</p>
      </div>

      <div class="network-badge">
        <span>üåê</span>
        <span>Fuji Testnet (Chain ID: 43113)</span>
      </div>

      <div class="grid">
        <!-- Wallet Connection Card -->
        <div class="card">
          <h3 class="card-title">
            <span class="card-icon">üëõ</span>
            Wallet Connection
          </h3>

          <div id="walletStatus">
            <button class="btn btn-success" onclick="connectWallet()">
              <span>üîó</span>
              Connect MetaMask
            </button>
          </div>

          <div id="walletInfo" style="display: none">
            <div class="wallet-info">
              <h4>Connected Account</h4>
              <p id="accountAddress"></p>
            </div>
            <div class="wallet-info">
              <h4>Balance</h4>
              <p id="accountBalance">Loading...</p>
            </div>
            <button class="btn btn-secondary" onclick="refreshBalance()">
              <span>üîÑ</span>
              Refresh Balance
            </button>
          </div>
        </div>

        <!-- Network Setup Card -->
        <div class="card">
          <h3 class="card-title">
            <span class="card-icon">‚öôÔ∏è</span>
            Network Setup
          </h3>

          <button class="btn btn-secondary" onclick="addAvalancheNetwork()">
            <span>‚ûï</span>
            Add Avalanche Network
          </button>
          <button class="btn btn-secondary" onclick="switchNetwork()">
            <span>üîÑ</span>
            Switch Network
          </button>
          <button class="btn btn-secondary" onclick="getNetworkInfo()">
            <span>‚ÑπÔ∏è</span>
            Network Info
          </button>

          <div id="networkStatus"></div>
        </div>

        <!-- Transaction Card -->
        <div class="card full-width">
          <h3 class="card-title">
            <span class="card-icon">üí∏</span>
            Send Transaction
          </h3>

          <div class="grid">
            <div>
              <div class="input-group">
                <label for="recipientAddress">Recipient Address</label>
                <input
                  type="text"
                  id="recipientAddress"
                  class="input"
                  placeholder="0x..."
                />
              </div>

              <div class="input-group">
                <label for="amount">Amount (AVAX)</label>
                <input
                  type="number"
                  id="amount"
                  class="input"
                  placeholder="0.1"
                  step="0.001"
                  min="0"
                />
              </div>
            </div>

            <div>
              <div class="input-group">
                <label for="gasLimit">Gas Limit (optional)</label>
                <input
                  type="number"
                  id="gasLimit"
                  class="input"
                  placeholder="21000"
                  min="21000"
                />
              </div>

              <div style="margin-top: 32px">
                <button class="btn btn-secondary" onclick="estimateGas()">
                  <span>‚õΩ</span>
                  Estimate Gas
                </button>
              </div>
            </div>
          </div>

          <button
            class="btn btn-success"
            onclick="sendTransaction()"
            id="sendBtn"
          >
            <span>üöÄ</span>
            Send Transaction
          </button>

          <div id="transactionStatus"></div>

          <div id="transactionResult" style="display: none">
            <div class="transaction-result">
              <h4>‚úÖ Transaction Sent!</h4>
              <div class="wallet-info">
                <h4>Transaction Hash</h4>
                <p id="txHash"></p>
              </div>
              <button class="btn btn-secondary" onclick="checkTransaction()">
                <span>üîç</span>
                Check Status
              </button>
              <button class="btn btn-secondary" onclick="openExplorer()">
                <span>üîó</span>
                View on Explorer
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Load Web3.js first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/4.2.2/web3.min.js"></script>

    <script>
      // Avalanche Fuji Testnet configuration
      const AVALANCHE_TESTNET = {
        chainId: "0xA869", // 43113 in hex
        chainName: "Avalanche Fuji Testnet",
        nativeCurrency: {
          name: "AVAX",
          symbol: "AVAX",
          decimals: 18,
        },
        rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
        blockExplorerUrls: ["https://testnet.snowtrace.io/"],
      };

      let web3;
      let userAccount;
      let currentTxHash;

      // Check if MetaMask is installed and available
      function checkMetaMaskAvailable() {
        if (typeof window.ethereum !== "undefined") {
          console.log("MetaMask detected!");
          return true;
        } else {
          showStatus(
            "‚ùå MetaMask not detected. Please install MetaMask extension.",
            "error"
          );
          return false;
        }
      }

      // Connect to MetaMask wallet
      async function connectWallet() {
        console.log("Connecting wallet...");

        if (!checkMetaMaskAvailable()) {
          return;
        }

        try {
          // Show loading state
          const walletStatus = document.getElementById("walletStatus");
          walletStatus.innerHTML = `
                    <button class="btn btn-secondary pulse" disabled>
                        <span class="loading"></span>
                        Connecting...
                    </button>
                `;

          // Request account access
          console.log("Requesting accounts...");
          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts",
          });

          console.log("Accounts received:", accounts);

          if (accounts && accounts.length > 0) {
            userAccount = accounts[0];
            console.log("Connected account:", userAccount);

            // Initialize Web3 with MetaMask provider
            web3 = new Web3(window.ethereum);
            console.log("Web3 initialized");

            // Update UI to show connected state
            updateWalletUI();

            // Get and display balance
            await refreshBalance();

            // Set up event listeners for account/network changes
            setupEventListeners();

            showStatus("‚úÖ Wallet connected successfully!", "success");
          } else {
            console.error("No accounts returned");
            showStatus(
              "‚ùå No accounts found. Please unlock MetaMask and try again.",
              "error"
            );
            resetWalletUI();
          }
        } catch (error) {
          console.error("Wallet connection error:", error);
          let errorMessage = "Failed to connect wallet";

          if (error.code === 4001) {
            errorMessage = "Connection rejected by user";
          } else if (error.code === -32002) {
            errorMessage = "Connection request already pending";
          } else if (error.message) {
            errorMessage = error.message;
          }

          showStatus(`‚ùå ${errorMessage}`, "error");
          resetWalletUI();
        }
      }

      // Update wallet UI when connected
      function updateWalletUI() {
        const walletStatus = document.getElementById("walletStatus");
        walletStatus.innerHTML = `
                <div class="status success">
                    <span>‚úÖ</span>
                    <span>Wallet Connected</span>
                </div>
                <button class="btn btn-danger" onclick="disconnectWallet()">
                    <span>üîå</span>
                    Disconnect
                </button>
            `;

        document.getElementById("accountAddress").textContent = userAccount;
        document.getElementById("walletInfo").style.display = "block";
      }

      // Reset wallet UI when disconnected
      function resetWalletUI() {
        const walletStatus = document.getElementById("walletStatus");
        walletStatus.innerHTML = `
                <button class="btn btn-success" onclick="connectWallet()">
                    <span>üîó</span>
                    Connect MetaMask
                </button>
            `;
        document.getElementById("walletInfo").style.display = "none";
      }

      // Disconnect wallet
      function disconnectWallet() {
        userAccount = null;
        web3 = null;
        currentTxHash = null;

        resetWalletUI();
        document.getElementById("transactionResult").style.display = "none";
        document.getElementById("transactionStatus").innerHTML = "";
        document.getElementById("networkStatus").innerHTML = "";

        showStatus("üîå Wallet disconnected", "warning");
      }

      // Setup event listeners for MetaMask events
      function setupEventListeners() {
        if (window.ethereum) {
          // Listen for account changes
          window.ethereum.on("accountsChanged", (accounts) => {
            console.log("Accounts changed:", accounts);
            if (accounts.length === 0) {
              disconnectWallet();
            } else if (accounts[0] !== userAccount) {
              userAccount = accounts[0];
              updateWalletUI();
              refreshBalance();
              showStatus("üîÑ Account changed", "warning");
            }
          });

          // Listen for chain changes
          window.ethereum.on("chainChanged", (chainId) => {
            console.log("Chain changed:", chainId);
            showStatus("üîÑ Network changed - page will reload", "warning");
            setTimeout(() => {
              window.location.reload();
            }, 1500);
          });

          // Listen for connection
          window.ethereum.on("connect", (connectInfo) => {
            console.log("Connected to network:", connectInfo);
          });

          // Listen for disconnection
          window.ethereum.on("disconnect", (error) => {
            console.log("Disconnected from network:", error);
            disconnectWallet();
          });
        }
      }

      // Refresh account balance
      async function refreshBalance() {
        if (!web3 || !userAccount) {
          showStatus("‚ùå Please connect wallet first", "error");
          return;
        }

        try {
          console.log("Getting balance for:", userAccount);
          const balanceWei = await web3.eth.getBalance(userAccount);
          const balanceEth = web3.utils.fromWei(balanceWei, "ether");
          const formattedBalance = parseFloat(balanceEth).toFixed(6);

          document.getElementById(
            "accountBalance"
          ).textContent = `${formattedBalance} AVAX`;
          console.log("Balance updated:", formattedBalance, "AVAX");
        } catch (error) {
          console.error("Error getting balance:", error);
          showStatus(`‚ùå Error getting balance: ${error.message}`, "error");
          document.getElementById("accountBalance").textContent =
            "Error loading balance";
        }
      }

      // Add Avalanche network to MetaMask
      async function addAvalancheNetwork() {
        if (!checkMetaMaskAvailable()) return;

        try {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [AVALANCHE_TESTNET],
          });
          showStatus("‚úÖ Avalanche Testnet added successfully!", "success");
        } catch (error) {
          console.error("Error adding network:", error);
          if (error.code === 4001) {
            showStatus("‚ùå Network addition rejected by user", "error");
          } else {
            showStatus(`‚ùå Error adding network: ${error.message}`, "error");
          }
        }
      }

      // Switch to Avalanche network
      async function switchNetwork() {
        if (!checkMetaMaskAvailable()) return;

        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: AVALANCHE_TESTNET.chainId }],
          });
          showStatus("‚úÖ Switched to Avalanche Testnet!", "success");
        } catch (error) {
          console.error("Error switching network:", error);
          if (error.code === 4902) {
            // Network not added yet
            showStatus(
              "‚ö†Ô∏è Network not found. Adding Avalanche Testnet...",
              "warning"
            );
            await addAvalancheNetwork();
          } else if (error.code === 4001) {
            showStatus("‚ùå Network switch rejected by user", "error");
          } else {
            showStatus(`‚ùå Error switching network: ${error.message}`, "error");
          }
        }
      }

      // Get current network information
      async function getNetworkInfo() {
        if (!web3) {
          showStatus("‚ùå Please connect wallet first", "error");
          return;
        }

        try {
          const networkId = await web3.eth.net.getId();
          const chainId = await web3.eth.getChainId();
          const blockNumber = await web3.eth.getBlockNumber();

          const isCorrectNetwork = Number(chainId) === 43113;

          const networkInfo = `
                    <div class="wallet-info">
                        <h4>Network Information</h4>
                        <p><strong>Network ID:</strong> ${networkId}</p>
                        <p><strong>Chain ID:</strong> ${chainId}</p>
                        <p><strong>Latest Block:</strong> ${blockNumber}</p>
                        <p><strong>Status:</strong> ${
                          isCorrectNetwork
                            ? "‚úÖ Avalanche Fuji Testnet"
                            : "‚ùå Wrong Network"
                        }</p>
                    </div>
                `;

          document.getElementById("networkStatus").innerHTML = networkInfo;

          if (!isCorrectNetwork) {
            showStatus("‚ö†Ô∏è Please switch to Avalanche Fuji Testnet", "warning");
          }
        } catch (error) {
          console.error("Error getting network info:", error);
          showStatus(
            `‚ùå Error getting network info: ${error.message}`,
            "error"
          );
        }
      }

      // Estimate gas for transaction
      async function estimateGas() {
        if (!web3 || !userAccount) {
          showStatus("‚ùå Please connect wallet first", "error");
          return;
        }

        const recipient = document
          .getElementById("recipientAddress")
          .value.trim();
        const amount = document.getElementById("amount").value;

        if (!recipient || !amount || amount <= 0) {
          showStatus(
            "‚ùå Please enter valid recipient address and amount",
            "error"
          );
          return;
        }

        if (!web3.utils.isAddress(recipient)) {
          showStatus("‚ùå Invalid recipient address format", "error");
          return;
        }

        try {
          const amountWei = web3.utils.toWei(amount.toString(), "ether");

          const gasEstimate = await web3.eth.estimateGas({
            from: userAccount,
            to: recipient,
            value: amountWei,
          });

          const gasPrice = await web3.eth.getGasPrice();
          const totalGasCost = BigInt(gasEstimate) * BigInt(gasPrice);
          const gasCostEth = web3.utils.fromWei(
            totalGasCost.toString(),
            "ether"
          );

          showStatus(
            `‚õΩ Estimated Gas: ${gasEstimate} units, Cost: ~${parseFloat(
              gasCostEth
            ).toFixed(6)} AVAX`,
            "success"
          );

          // Auto-fill gas limit with some buffer
          document.getElementById("gasLimit").value = Math.ceil(
            Number(gasEstimate) * 1.2
          );
        } catch (error) {
          console.error("Error estimating gas:", error);
          showStatus(`‚ùå Error estimating gas: ${error.message}`, "error");
        }
      }

      // Send transaction
      async function sendTransaction() {
        if (!web3 || !userAccount) {
          showStatus("‚ùå Please connect wallet first", "error");
          return;
        }

        const recipient = document
          .getElementById("recipientAddress")
          .value.trim();
        const amount = document.getElementById("amount").value;
        const gasLimit = document.getElementById("gasLimit").value || "21000";

        // Validation
        if (!recipient || !amount || amount <= 0) {
          showStatus(
            "‚ùå Please enter valid recipient address and amount",
            "error"
          );
          return;
        }

        if (!web3.utils.isAddress(recipient)) {
          showStatus("‚ùå Invalid recipient address format", "error");
          return;
        }

        const sendBtn = document.getElementById("sendBtn");
        const originalHTML = sendBtn.innerHTML;
        sendBtn.innerHTML = '<span class="loading"></span> Sending...';
        sendBtn.disabled = true;

        try {
          const amountWei = web3.utils.toWei(amount.toString(), "ether");

          const transactionParameters = {
            from: userAccount,
            to: recipient,
            value: amountWei,
            gas: gasLimit,
          };

          console.log("Sending transaction:", transactionParameters);

          const txHash = await window.ethereum.request({
            method: "eth_sendTransaction",
            params: [transactionParameters],
          });

          console.log("Transaction sent:", txHash);
          currentTxHash = txHash;

          // Update UI
          document.getElementById("txHash").textContent = txHash;
          document.getElementById("transactionResult").style.display = "block";

          showStatus(
            "‚úÖ Transaction sent successfully! Waiting for confirmation...",
            "success"
          );

          // Clear form
          document.getElementById("recipientAddress").value = "";
          document.getElementById("amount").value = "";
          document.getElementById("gasLimit").value = "";

          // Wait a bit then refresh balance
          setTimeout(() => {
            refreshBalance();
            checkTransaction();
          }, 3000);
        } catch (error) {
          console.error("Transaction error:", error);
          let errorMessage = "Transaction failed";

          if (error.code === 4001) {
            errorMessage = "Transaction rejected by user";
          } else if (error.code === -32603) {
            errorMessage =
              "Transaction failed - insufficient funds or network error";
          } else if (error.message) {
            errorMessage = error.message;
          }

          showStatus(`‚ùå ${errorMessage}`, "error");
        } finally {
          sendBtn.innerHTML = originalHTML;
          sendBtn.disabled = false;
        }
      }

      // Check transaction status
      async function checkTransaction() {
        if (!web3 || !currentTxHash) {
          showStatus("‚ùå No transaction hash found", "error");
          return;
        }

        try {
          console.log("Checking transaction:", currentTxHash);

          const receipt = await web3.eth.getTransactionReceipt(currentTxHash);

          if (receipt) {
            const success = receipt.status;
            const blockNumber = receipt.blockNumber;
            const gasUsed = receipt.gasUsed;

            const statusInfo = `
                        <div class="wallet-info">
                            <h4>Transaction Status</h4>
                            <p><strong>Status:</strong> ${
                              success ? "‚úÖ Confirmed" : "‚ùå Failed"
                            }</p>
                            <p><strong>Block:</strong> ${blockNumber}</p>
                            <p><strong>Gas Used:</strong> ${gasUsed}</p>
                        </div>
                    `;

            document.getElementById("transactionStatus").innerHTML = statusInfo;

            if (success) {
              showStatus("‚úÖ Transaction confirmed successfully!", "success");
              refreshBalance();
            } else {
              showStatus("‚ùå Transaction failed", "error");
            }
          } else {
            showStatus("‚è≥ Transaction still pending...", "warning");
            // Check again in 5 seconds if still pending
            setTimeout(checkTransaction, 5000);
          }
        } catch (error) {
          console.error("Error checking transaction:", error);
          showStatus(
            `‚ùå Error checking transaction: ${error.message}`,
            "error"
          );
        }
      }

      // Open transaction in explorer
      function openExplorer() {
        if (currentTxHash) {
          const explorerUrl = `https://testnet.snowtrace.io/tx/${currentTxHash}`;
          window.open(explorerUrl, "_blank");
        } else {
          showStatus("‚ùå No transaction hash available", "error");
        }
      }

      // Show status message
      function showStatus(message, type) {
        const statusDiv = document.getElementById("transactionStatus");
        const icon = type === "success" ? "‚úÖ" : type === "error" ? "‚ùå" : "‚ö†Ô∏è";

        statusDiv.innerHTML = `
                <div class="status ${type}">
                    <span>${icon}</span>
                    <span>${message}</span>
                </div>
            `;

        // Auto-clear success messages after 5 seconds
        if (type === "success") {
          setTimeout(() => {
            if (statusDiv.innerHTML.includes(message)) {
              statusDiv.innerHTML = "";
            }
          }, 5000);
        }
      }

      // Check if user is already connected when page loads
      async function checkExistingConnection() {
        if (!checkMetaMaskAvailable()) return;

        try {
          const accounts = await window.ethereum.request({
            method: "eth_accounts",
          });

          if (accounts && accounts.length > 0) {
            console.log("Found existing connection:", accounts[0]);
            userAccount = accounts[0];
            web3 = new Web3(window.ethereum);
            updateWalletUI();
            await refreshBalance();
            setupEventListeners();

            // Check if on correct network
            const chainId = await web3.eth.getChainId();
            if (Number(chainId) !== 43113) {
              showStatus(
                "‚ö†Ô∏è Please switch to Avalanche Fuji Testnet",
                "warning"
              );
            }
          }
        } catch (error) {
          console.error("Error checking existing connection:", error);
        }
      }

      // Initialize app when page loads
      window.addEventListener("load", async () => {
        console.log("Page loaded, checking for existing connections...");
        await checkExistingConnection();
      });

      // Handle page visibility change to refresh data when user returns
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden && userAccount && web3) {
          refreshBalance();
        }
      });
    </script>
  </body>
</html>
